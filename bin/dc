#!/usr/bin/env bash
set -euo pipefail

# Dev Container Management using Docker (OrbStack)
# Uses Docker API for better mount support and container management

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
CONTAINER_PREFIX="dev-"
DOCKER_IMAGE="ubuntu:22.04"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Check if Docker (OrbStack) is available
check_docker() {
    if ! command -v docker &> /dev/null; then
        log_error "Docker not found. Please install OrbStack."
        exit 1
    fi
}

# List all dev containers
list_containers() {
    log_info "Development containers:"
    docker ps -a --filter "name=^${CONTAINER_PREFIX}" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
}

# Create a new dev container
create_container() {
    local name="$1"
    local container_name="${CONTAINER_PREFIX}${name}"

    if docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_error "Container '${container_name}' already exists"
        exit 1
    fi

    # Validate required directories exist
    if [ ! -d "$HOME/git" ]; then
        log_warn "Creating ~/git directory..."
        mkdir -p "$HOME/git"
    fi

    if [ ! -d "$HOME/.ssh" ]; then
        log_error "SSH directory ~/.ssh does not exist"
        exit 1
    fi

    log_info "Creating container '${container_name}'..."

    # Detect platform
    local platform
    case "$(uname -m)" in
        x86_64)
            platform="linux/amd64"
            ;;
        arm64|aarch64)
            platform="linux/arm64"
            ;;
        *)
            log_error "Unsupported architecture: $(uname -m)"
            exit 1
            ;;
    esac

    log_info "Using platform: ${platform}"

    # Create container with proper mounts and settings
    docker run -d \
        --name "${container_name}" \
        --hostname "${container_name}" \
        --platform "${platform}" \
        -v "$HOME/git:/home/dan/git" \
        -v "$HOME/.ssh:/mnt/host-ssh:ro" \
        -v "$DOTFILES_DIR:/mnt/dotfiles:ro" \
        -v "$HOME/.claude:/home/dan/.claude" \
        -v "$HOME/.claude.json:/home/dan/.claude.json" \
        --tmpfs /tmp:exec \
        --tmpfs /run \
        --privileged \
        "${DOCKER_IMAGE}" \
        /bin/bash -c "while true; do sleep 1000; done"

    # Wait for container to be ready
    sleep 2

    log_info "Installing base packages..."
    docker exec "${container_name}" bash -c 'export DEBIAN_FRONTEND=noninteractive && apt-get update && apt-get install -y curl git sudo xz-utils build-essential locales zsh rsync systemd systemd-sysv libssl-dev pkg-config cmake libclang-dev lld'

    log_info "Setting up locale..."
    docker exec "${container_name}" bash -c 'locale-gen en_US.UTF-8 && update-locale LANG=en_US.UTF-8'

    log_info "Creating user..."
    docker exec "${container_name}" bash -c '
        # Check if staff group exists and get its GID
        if getent group staff > /dev/null 2>&1; then
            STAFF_GID=$(getent group staff | cut -d: -f3)
            echo "Using existing staff group with GID $STAFF_GID"
        else
            # Create staff group with GID 20 if it doesnt exist
            groupadd -g 20 staff
            STAFF_GID=20
        fi

        # Create user with UID 501 and the staff group
        useradd -m -u 501 -g staff -G sudo -s /bin/zsh dan || true
        echo "dan ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/dan
        chown dan:staff /home/dan
    '


    log_info "Installing Nix..."
    # Download and run Nix installer from home directory to avoid /tmp execution issues
    docker exec -u dan "${container_name}" bash -c '
        cd ~
        export TMPDIR=$HOME/tmp
        mkdir -p $TMPDIR
        curl -L https://nixos.org/nix/install -o install-nix.sh
        chmod +x install-nix.sh
        ./install-nix.sh --no-daemon
        rm -f install-nix.sh
        rm -rf $TMPDIR

        # Debug: Check what files were created
        echo "=== Checking Nix installation files ==="
        ls -la ~/.local/state/nix/profiles/profile/etc/profile.d/ 2>/dev/null || echo "No profile.d in .local/state"
        ls -la ~/.nix-profile 2>/dev/null || echo "No ~/.nix-profile symlink"
        ls -la ~/.profile 2>/dev/null || echo "No ~/.profile"
        ls -la ~/.bashrc 2>/dev/null || echo "No ~/.bashrc"
        echo "=== Checking .profile contents for nix ==="
        grep -n "nix" ~/.profile 2>/dev/null || echo "No nix in .profile"
        echo "=== End debug ==="
    '

    # Add nix to shell profiles (for bash/profile only, zshrc will be created separately)
    docker exec -u dan "${container_name}" bash -c '
        # The actual nix profile location after install
        echo "if [ -e ~/.local/state/nix/profiles/profile/etc/profile.d/nix.sh ]; then . ~/.local/state/nix/profiles/profile/etc/profile.d/nix.sh; fi" >> ~/.bashrc
        echo "if [ -e ~/.local/state/nix/profiles/profile/etc/profile.d/nix.sh ]; then . ~/.local/state/nix/profiles/profile/etc/profile.d/nix.sh; fi" >> ~/.profile
    '

    # Set up SSH keys for git access
    log_info "Setting up SSH keys..."
    docker exec -u dan "${container_name}" bash -c '
        # Create .ssh directory with proper permissions
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh

        # Copy SSH keys from mounted volume (read-only) to home directory
        if [ -d /mnt/host-ssh ]; then
            # Copy private keys (all files without .pub extension)
            for key in /mnt/host-ssh/*; do
                if [ -f "$key" ] && [[ ! "$key" =~ \.pub$ ]] && [[ ! "$key" =~ known_hosts$ ]] && [[ ! "$key" =~ config$ ]] && [[ ! "$key" =~ authorized_keys$ ]]; then
                    cp "$key" ~/.ssh/
                    chmod 600 ~/.ssh/$(basename "$key")
                fi
            done

            # Copy public keys
            for key in /mnt/host-ssh/*.pub; do
                if [ -f "$key" ]; then
                    cp "$key" ~/.ssh/
                    chmod 644 ~/.ssh/$(basename "$key")
                fi
            done

            # Copy SSH config if it exists
            if [ -f /mnt/host-ssh/config ]; then
                cp /mnt/host-ssh/config ~/.ssh/
                chmod 644 ~/.ssh/config
            fi

            # Copy known_hosts if it exists
            if [ -f /mnt/host-ssh/known_hosts ]; then
                cp /mnt/host-ssh/known_hosts ~/.ssh/
                chmod 644 ~/.ssh/known_hosts
            fi
        fi
    '

    # Link dotfiles and set up shell configuration
    log_info "Setting up dotfiles..."
    docker exec -u dan "${container_name}" bash -c '
        # Link dotfiles directory
        ln -s /mnt/dotfiles ~/dotfiles

        # Create .config directory if it doesnt exist
        mkdir -p ~/.config
        mkdir -p ~/.config/nix

        # Create nix.conf to enable flakes before home-manager runs
        cat > ~/.config/nix/nix.conf << '\''EOF'\''
experimental-features = nix-command flakes
keep-derivations = true
keep-outputs = true
EOF

        # Create a temporary .zshrc that will be replaced by home-manager
        # This ensures nix is available for the home-manager switch command
        if [ ! -f ~/.zshrc ]; then
            cat > ~/.zshrc << '\''EOF'\''
# Temporary .zshrc - will be replaced by home-manager
if [ -e ~/.local/state/nix/profiles/profile/etc/profile.d/nix.sh ]; then
    . ~/.local/state/nix/profiles/profile/etc/profile.d/nix.sh
fi
EOF
        fi
    '

    # Install home-manager
    log_info "Installing home-manager..."
    if docker exec -u dan "${container_name}" env USER=dan bash -l -c '
        # The -l flag ensures we get a login shell which sources .profile
        nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager
        nix-channel --update
    ' 2>&1; then
        log_info "Nix channels updated successfully"
    else
        log_warn "nix-channel update had issues, continuing anyway"
    fi

    # Wait a bit for channels
    sleep 2

    # Install home-manager
    if docker exec -u dan "${container_name}" env USER=dan bash -l -c '
        nix-shell "<home-manager>" -A install
    ' 2>&1; then
        log_info "Home-manager installed successfully"
    else
        log_warn "home-manager install had issues, continuing anyway"
    fi

    # Apply home-manager configuration
    log_info "Applying home-manager configuration..."
    log_info "This will set up your shell and development tools"
    if docker exec -u dan "${container_name}" env USER=dan bash -l -c '
        cd ~/dotfiles
        # Set HOME_MANAGER_BACKUP_EXT to avoid conflicts with our custom .zshrc
        export HOME_MANAGER_BACKUP_EXT=.bak
        home-manager switch --flake .#linux-aarch64
    ' 2>&1; then
        log_info "Home-manager configuration applied successfully"
    else
        log_warn "home-manager switch failed, but container is still usable"
        log_warn "You can manually run: home-manager switch --flake ~/dotfiles#linux-aarch64"
    fi


    # Get container IP
    local container_ip=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${container_name}")

    log_info "Container '${container_name}' created successfully!"
    log_info ""
    log_info "To access the container:"
    log_info "  dc shell ${name}"
    log_info ""
    log_info "Other commands:"
    log_info "  dc exec ${name} <command>    # Run a command"
    log_info "  dc rebuild ${name}           # Rebuild home-manager config"
    log_info "  dc stop ${name}              # Stop container"
    log_info "  dc start ${name}             # Start container"
    log_info "  dc destroy ${name}           # Remove container"
    log_info ""
    log_info "Mounts:"
    log_info "  ~/git -> /home/dan/git (read-write)"
    log_info "  ~/.ssh -> /mnt/host-ssh (read-only, copied to ~/.ssh)"
    log_info "  dotfiles -> /mnt/dotfiles (read-only)"
    log_info ""
    log_info "SSH keys have been copied to the container for git operations."
}

# Destroy a dev container
destroy_container() {
    local name="$1"
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if ! docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_error "Container '${container_name}' does not exist"
        exit 1
    fi

    read -p "Are you sure you want to destroy '${container_name}'? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_info "Destroying container '${container_name}'..."
        docker rm -f "${container_name}"
        log_info "Container destroyed"
    else
        log_info "Cancelled"
    fi
}

# Force destroy without prompt
force_destroy_container() {
    local name="$1"
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_info "Force destroying container '${container_name}'..."
        docker rm -f "${container_name}"
    fi
}


# Shell into a container
shell_container() {
    local name="$1"
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if ! docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_error "Container '${container_name}' does not exist"
        exit 1
    fi

    # Check if container is running
    if ! docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_warn "Container '${container_name}' is not running. Starting it..."
        docker start "${container_name}"
        sleep 2
    fi

    # Use docker exec with proper environment
    # We need to use a login shell to ensure all initialization files are sourced
    docker exec -it -u dan -w /home/dan "${container_name}" env TERM=xterm-256color USER=dan HOME=/home/dan zsh -l
}

# Rebuild container configuration
rebuild_container() {
    local name="$1"
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if ! docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_error "Container '${container_name}' does not exist"
        exit 1
    fi

    log_info "Rebuilding configuration for '${container_name}'..."

    # Update home-manager
    docker exec -u dan "${container_name}" env USER=dan bash -l -c '
        cd ~/dotfiles
        # Skip git pull since dotfiles is mounted read-only
        echo "Using mounted dotfiles (read-only)"
        home-manager switch --flake .#linux-aarch64
    ' || {
        log_warn "home-manager switch failed"
        return 1
    }

    log_info "Configuration rebuilt successfully"
}

# Execute command in container
exec_container() {
    local name="$1"
    shift
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if ! docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_error "Container '${container_name}' does not exist"
        exit 1
    fi

    # Check if container is running
    if ! docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_warn "Container '${container_name}' is not running. Starting it..."
        docker start "${container_name}"
        sleep 2
    fi

    docker exec -u dan -w /home/dan "${container_name}" env USER=dan bash -l -c "$*"
}

# Start a stopped container
start_container() {
    local name="$1"
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if ! docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_warn "Container '${container_name}' does not exist"
        read -p "Would you like to create it? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            create_container "${name}"
            return
        else
            log_error "Container '${container_name}' does not exist"
            exit 1
        fi
    fi

    # Check if already running
    if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_info "Container '${container_name}' is already running"
        return
    fi

    log_info "Starting container '${container_name}'..."
    docker start "${container_name}"


    log_info "Container started"
}

# Update SSH keys in container
update_ssh_keys() {
    local name="$1"
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if ! docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_error "Container '${container_name}' does not exist"
        exit 1
    fi

    log_info "Updating SSH keys in '${container_name}'..."

    docker exec -u dan "${container_name}" bash -c '
        # Create .ssh directory with proper permissions
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh

        # Copy SSH keys from mounted volume (read-only) to home directory
        if [ -d /mnt/host-ssh ]; then
            # Copy private keys (all files without .pub extension)
            for key in /mnt/host-ssh/*; do
                if [ -f "$key" ] && [[ ! "$key" =~ \.pub$ ]] && [[ ! "$key" =~ known_hosts$ ]] && [[ ! "$key" =~ config$ ]] && [[ ! "$key" =~ authorized_keys$ ]]; then
                    cp "$key" ~/.ssh/
                    chmod 600 ~/.ssh/$(basename "$key")
                fi
            done

            # Copy public keys
            for key in /mnt/host-ssh/*.pub; do
                if [ -f "$key" ]; then
                    cp "$key" ~/.ssh/
                    chmod 644 ~/.ssh/$(basename "$key")
                fi
            done

            # Copy SSH config if it exists
            if [ -f /mnt/host-ssh/config ]; then
                cp /mnt/host-ssh/config ~/.ssh/
                chmod 644 ~/.ssh/config
            fi

            # Copy known_hosts if it exists
            if [ -f /mnt/host-ssh/known_hosts ]; then
                cp /mnt/host-ssh/known_hosts ~/.ssh/
                chmod 644 ~/.ssh/known_hosts
            fi

            echo "SSH keys updated successfully"
        else
            echo "No /mnt/host-ssh directory found"
            exit 1
        fi
    '

    log_info "SSH keys updated successfully"
}

# Stop a running container
stop_container() {
    local name="$1"
    # Check if name already has the prefix
    if [[ "$name" == "${CONTAINER_PREFIX}"* ]]; then
        local container_name="$name"
    else
        local container_name="${CONTAINER_PREFIX}${name}"
    fi

    if ! docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        log_error "Container '${container_name}' does not exist"
        exit 1
    fi

    log_info "Stopping container '${container_name}'..."
    docker stop "${container_name}"
    log_info "Container stopped"
}

# Main command handler
main() {
    check_docker

    case "${1:-}" in
        list|ls)
            list_containers
            ;;
        create)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 create <name>"
                exit 1
            fi
            create_container "$2"
            ;;
        destroy|rm)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 destroy <name>"
                exit 1
            fi
            destroy_container "$2"
            ;;
        force-destroy|force-rm)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 force-destroy <name>"
                exit 1
            fi
            force_destroy_container "$2"
            ;;
        shell)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 shell <name>"
                exit 1
            fi
            shell_container "$2"
            ;;
        start)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 start <name>"
                exit 1
            fi
            start_container "$2"
            ;;
        stop)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 stop <name>"
                exit 1
            fi
            stop_container "$2"
            ;;
        rebuild)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 rebuild <name>"
                exit 1
            fi
            rebuild_container "$2"
            ;;
        exec)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 exec <name> <command>"
                exit 1
            fi
            name="$2"
            shift 2
            exec_container "$name" "$@"
            ;;
        update-ssh)
            if [ -z "${2:-}" ]; then
                log_error "Usage: $0 update-ssh <name>"
                exit 1
            fi
            update_ssh_keys "$2"
            ;;
        *)
            echo "Usage: $0 <command> [args]"
            echo ""
            echo "Commands:"
            echo "  list, ls              List all dev containers"
            echo "  create <name>         Create a new dev container"
            echo "  destroy, rm <name>    Destroy a dev container"
            echo "  force-destroy <name>  Force destroy without prompt"
            echo "  start <name>          Start a stopped container"
            echo "  stop <name>           Stop a running container"
            echo "  shell <name>          Open a shell in the container"
            echo "  rebuild <name>        Rebuild container configuration"
            echo "  exec <name> <cmd>     Execute command in container"
            echo "  update-ssh <name>     Update SSH keys in container"
            echo ""
            echo "Example:"
            echo "  $0 create myproject"
            echo "  $0 shell myproject"
            exit 1
            ;;
    esac
}

main "$@"
